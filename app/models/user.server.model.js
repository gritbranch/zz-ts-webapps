var mongoose = require('mongoose'),
	crypto = require('crypto'),
    Schema = mongoose.Schema;

//Defines your UserSchema object using the Schema constructor, and then you used the schema instance to define your User model.
var UserSchema = new Schema({
	firstName: String,
	lastName: String,
	email: {
    	type: String,
    	//Index property could optimize these queries by creating an e-mail secondary index.
		index: true,
    	//Match property varifies that the field matches the given regex expression.
		match: /.+\@.+\..+/
  	},
	username: {
    	type: String,
		//Validates the uniqueness of a document field across a collection.
		unique: true,
    	//Required property verifies the existence of the field before saving.
		//If a validation error occurs, save is aborted and error is passed to callback.
		required: 'Username is required',
    	//A modifier can either change the field's value before saving the document or represent it differently at query time.
		//Trim is modifier a leading and trailing whitespace.
		trim: true
  	},
	password: {
    	type: String,
		//Custom validator is done using the validate property.
    	//Validate property value should be an array consisting of a validation function and an error message.
		validate: [
    		function(password) {
        		return password && password.length > 6;
      		}, 'Password should be longer'
		]
  	},
	//Used to hash password
	salt: {
		type: String
	},
	//Will indicate the strategy used to register the user
	provider: {
		type: String,
		required: 'Provider is required'
	},
	//Will indicate the user identifier for the authentication strategy
	providerId: String,
	//Will use to store the user object retrieved from OAuth providers
	providerData: {},		  
	created: {
    	type: Date,
    	//Setting a default value
		default: Date.now
  	}
});

//Virtual attributes are dynamically calculated properties which are not really presented in the document.
UserSchema.virtual('fullName')
	.get(function() {
  		return this.firstName + ' ' + this.lastName;
	})
	//Virtual attributes can also have setters (e.g. break full name to first name and last name).
	.set(function(fullName) {
  		var splitName = fullName.split(' '); 
  		this.firstName = splitName[0] || ''; 
  		this.lastName = splitName[1] || ''; 
	});

//Pre-save middleware to handle the hashing of your users' passwords
//Pre-save middleware performs two important steps: first, it creates an autogenerated pseudo-random hashing salt, 
//and then it replaces the current user password with a hashed password using the hashPassword() instance method
UserSchema.pre('save', function(next) {
  if (this.password) {
    this.salt = new Buffer(crypto.randomBytes(16).toString('base64'), 'base64');
    this.password = this.hashPassword(this.password);
  }

  next();
});

//Used to hash a password string by utilizing Node.js' crypto module
UserSchema.methods.hashPassword = function(password) {
	return crypto.pbkdf2Sync(password, this.salt, 10000, 64).toString('base64');
};

//Custom instance methods are methods that perform instance operations.
//Need to be declared as a member of your schema's methods property.
//This allows authenticate method to be called from any User model instance (i.e. user.authenticate('password');).
//Accepts a string argument, hashes it, and compares it to the current user's hashed password
UserSchema.methods.authenticate = function(password) {
 	return this.password === this.hashPassword(password);
};

//Used to find an available unique username for new users.
UserSchema.statics.findUniqueUsername = function(username, suffix, callback) {
	var _this = this;
	var possibleUsername = username + (suffix || '');
	
	_this.findOne({
		username: possibleUsername
	}, function(err, user) {
		if (!err) {
			if (!user) {
			callback(possibleUsername);
			} else {
			return _this.findUniqueUsername(username, (suffix || 0) + 1, callback);
			}
		} else {
			callback(null);
		}
	});
};

//This will force Mongoose to include getters when converting the MongoDB document to a JSON representation and will allow the output of documents using res.json() to include the getter's behavior.
UserSchema.set('toJSON', { getters: true, virtuals: true });

mongoose.model('User', UserSchema);